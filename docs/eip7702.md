# EIP7702

## Abstract

**EIP-7702** (SET code for EOAs) is an Ethereum Improvement Proposal that allows **temporarily setting contract code on EOAs (Externally Owned Accounts)**, enabling EOAs to execute complex logic like smart contracts. This provides a complementary approach to account abstraction.

## Key Concepts Comparison

| Feature | EIP-4337 | EIP-7702 |
|---------|----------|---------|
| **Account Type** | Smart Contract Account | EOA-derived Account |
| **Initialization** | Contract Deployment | Signature Authorization |
| **Cost** | High (Deployment) | Low (Authorization Only) |
| **Flexibility** | Maximum | Medium (Code-constrained) |
| **Fallback** | Contract Logic | Fallback to EOA |

## Workflow

```
┌─────────────────────────────────────────────────────────┐
│              EIP-7702 Account Abstraction Flow           │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  1️⃣  Create Authorization                              │
│      └─ Structure: [chainId, delegateAddress, nonce]   │
│      └─ RLP-encoded with magic number (0x05)           │
│                                                          │
│  2️⃣  Sign Authorization                                 │
│      └─ Sign authorization hash with EOA private key   │
│      └─ Obtain signature: (r, s, v)                    │
│                                                          │
│  3️⃣  Broadcast Authorization                            │
│      └─ Include in transaction via authorizationList   │
│      └─ EOA code temporarily set to: 0xef0100 || addr  │
│                                                          │
│  4️⃣  Execute UserOperation                              │
│      └─ Send to EntryPoint like EIP-4337               │
│      └─ Delegate verifies signature and executes       │
│                                                          │
│  5️⃣  After Transaction                                  │
│      └─ EOA still usable afterwards                    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

## Authorization Data Format

**Authorization Structure**:
```solidity
struct Authorization {
    address delegateAddress;  // Delegate contract address
    uint256 chainId;          // Chain ID
    uint256 nonce;            // Current EOA nonce
    uint8 yParity;            // Signature yParity (0 or 1)
    bytes32 r;                // Signature r value
    bytes32 s;                // Signature s value
}
```

**Signature Message Construction**:
```
authHash = keccak256(0x05 || RLP([chainId, delegateAddress, nonce]))
```

## Security Considerations

- **Multiple authorizations**: If an EOA signs multiple EIP-7702 authorizations, any of them can be used in a transaction, leading to unpredictable or unsafe behavior. Storage collisions or logic conflicts may occur if different code is authorized for the same EOA.
- **Public signatures**: Once an EIP-7702 signature is used on-chain, it becomes public and can be replayed by anyone. Always use a nonce to allow revocation and prevent replay attacks.
- **Polymorphic accounts**: EOAs can behave as both contract and EOA across transactions. Protocols should not assume EXTCODESIZE is zero for EOAs.

---

## Best Practices & Security Notes

- **Always sign with a nonce**: Prevents replay attacks and allows revocation of authorizations.
- **Sign with chainId**: Avoids cross-chain replay unless explicitly intended.
- **Be cautious with multiple authorizations**: Multiple valid signatures can lead to unpredictable behavior and security risks.
- **Signed authorizations are public**: Once used, anyone can see them. If you do not use a nonce, they can be replayed by anyone—treat as sensitive as your private key. Always use a nonce to prevent replay.
- **Contract guidelines**: Use storage namespacing and support revocation in delegate contracts.
- **Wallet UI**: Clearly display code address, nonce, and chainId when signing EIP-7702 authorizations.